library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

--minimum depth size for fifo is 4 words. Assuming a width of 10 and a depth of 10,
--this should hold 10 entries of 10. Therefore the full signals will never be used.

--current issues: delay on startup, few empty button presses. Accumulate doesnt drain the fifo. or read anything in

--as we want to empty the fifo at 5 entries of 10.
entity lab6 is
		
	port (
		MAX10_CLK1_50 : in std_logic;
		KEY : in std_logic_vector(1 downto 0); --rst_l --add
		SW : in std_logic_vector(9 downto 0);
		LEDR : out std_logic_vector(9 downto 0);
		HEX0 : out unsigned(7 downto 0);
		HEX1 : out unsigned(7 downto 0);
		HEX2 : out unsigned(7 downto 0);
		HEX3 : out unsigned(7 downto 0);
		HEX4 : out unsigned(7 downto 0);
		HEX5 : out unsigned(7 downto 0)
	);
	
end entity lab6;
	
architecture behavioral of lab6 is 

	component wrstate
		port (
			clk : in std_logic;
			rst_l : in std_logic;
			data_in : in std_logic_vector(9 downto 0);
			data_enter : in std_logic;
			fifo_full : in std_logic;
			fifo_data : out std_logic_vector(9 downto 0);
			fifo_we : out std_logic
			);
			end component;
			
	component rdstate
		port (
			clk : in std_logic;
			rst_l : in std_logic;
		
			fifo_re : out std_logic;
			fifo_level : in std_logic_vector(2 downto 0);
			fifo_data : in std_logic_vector(9 downto 0);
			fifo_mt : in std_logic;
		
			HEX0 : out unsigned(7 downto 0);
			HEX1 : out unsigned(7 downto 0);
			HEX2 : out unsigned(7 downto 0);
			HEX3 : out unsigned(7 downto 0);
			HEX4 : out unsigned(7 downto 0);
			HEX5 : out unsigned(7 downto 0)
			);
			end component;
	
	component pll is
	
		PORT
	(
		areset		: IN STD_LOGIC  := '0';
		inclk0		: IN STD_LOGIC  := '0';
		c0		: OUT STD_LOGIC ;
		c1		: OUT STD_LOGIC 
	);
	end component;
	
	component fifo is
		PORT
	(
		aclr		: IN STD_LOGIC  := '0';
		data		: IN STD_LOGIC_VECTOR (9 DOWNTO 0);
		rdclk		: IN STD_LOGIC ;
		rdreq		: IN STD_LOGIC ;
		wrclk		: IN STD_LOGIC ;
		wrreq		: IN STD_LOGIC ;
		q		: OUT STD_LOGIC_VECTOR (9 DOWNTO 0);
		rdempty		: OUT STD_LOGIC ;
		rdusedw		: OUT STD_LOGIC_VECTOR (2 DOWNTO 0);
		wrfull		: OUT STD_LOGIC 
	);
	END component;
	
	signal rst : std_logic;
	signal clk5, clk12 :std_logic;
	signal fifo_re, fifo_we, fifo_mt : std_logic ;  --?????????????????????? consider not initializing this line
	signal fifo_level : std_logic_vector(2 downto 0);
	signal fifo_wdata, fifo_rdata : std_logic_vector(9 downto 0);

begin
		--fifo_re <= '0';

		
		LEDR <= SW; --sets LEDS to switches. This is all we need to do with LEDS.
		rst <= not key(0);
		
		
		u0_pll : pll
			port map (
				areset => '0',
				inclk0 => MAX10_CLK1_50,
				c0 => clk5,
				c1 => clk12
				);
		u1_wr : wrstate
			port map (
				clk => clk5,
				rst_l => key(0),
				data_in => sw,
				data_enter => key(1),
				fifo_full => '0',
				fifo_data => fifo_wdata,
				fifo_we => fifo_we
				);
				
		u2_fifo : fifo
			port map (
				aclr => rst,
				data => fifo_wdata,
				rdclk => clk12,
				rdreq => fifo_re,
				wrclk => clk5,
				wrreq => fifo_we,
				q => fifo_rdata,
				rdempty => fifo_mt,	
				rdusedw => fifo_level,	
	         wrfull => open
				);
				
		u3_rd : rdstate
			port map (
				clk 		   => clk12,
				rst_l 	   => key(0),
				            
				fifo_re 	   =>  fifo_re,
				fifo_level  =>  fifo_level,
				fifo_data   =>  fifo_rdata,
				fifo_mt     =>  fifo_mt,
				
				HEX0 		=> HEX0,
				HEX1 		=> HEX1,
				HEX2 		=> HEX2,
				HEX3 		=> HEX3,
				HEX4 		=> HEX4,
				HEX5 		=> HEX5
				);
				
		
	
	
	
	
end architecture behavioral;